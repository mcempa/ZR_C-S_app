====================
FILE: client.py
import socket as s
from services.ClientConnactionManager import ClientConnactionManager
from services.UserClientManager import UserClientManager


with ClientConnactionManager() as connation:
    user_manager = UserClientManager()
    while True:
        try:
            command, data_input = user_manager.prepere_request()
            #print(f"client command: {command}")
            #print(f"client data_input: {data_input}")
            
            if command not in user_manager.command_map:
                print("Nieznane polecenie. Spróbuj ponownie.")
                continue

            if command == "logout":
                try:
                    request = user_manager.command_map[command](command)
                    connation.send_request(str(request)) 
                    connation.recv_response()
                    break
                except Exception as e:
                    print(f"Błąd podczas wylogowywania: {str(e)}")
                    continue

            if command in user_manager.command_map:
                try:
                    if len(data_input) > 0:
                        request = user_manager.command_map[command](command, *data_input) 
                    elif len(data_input) == 0 and command != "logout":
                        request = user_manager.command_map[command](command)
                    #print(request)
                    connation.send_request(str(request)) 
                    connation.recv_response()
                except ConnectionError:
                    print("Błąd połączenia z serwerem. Sprawdź połączenie i spróbuj ponownie.")
                    break
                except Exception as e:
                    print(f"Wystąpił błąd: {str(e)}")
                    continue
        except KeyboardInterrupt:
            print("Program został przerwany przez użytkownika.")
            break
        except Exception as e:
            print(f"Wystąpił nieoczekiwany błąd: {str(e)}")
            continue

    
        

        


====================
FILE: ClientConnactionManager.py
import socket as s
import time
import os
from datetime import datetime
import json
from config import *

class ClientConnactionManager():
    def __init__(self):
        self.host = SERVER_CONFIG['host']
        self.port = SERVER_CONFIG['port']
    
    def __enter__(self):
        try:
            #Otwórz połączenie
            self.client_socket = s.socket(s.AF_INET, s.SOCK_STREAM)
            self.client_socket.connect((self.host, self.port))
            return self   # !!!!! nie self.client_socket
        
        except ConnectionRefusedError:
            print("Nie można połączyć się z serwerem - serwer nie jest uruchomiony")
            raise
        except Exception as e:
            print(f"Inny błąd podczas wysyłania komendy: {e}")
            raise

    def __exit__(self, exc_type, exc_value, traceback):
        #Zamknij połączenie
        if self.client_socket:
            self.client_socket.close()
            print("Połączenie z serwerem zostaje zamkniete")

    def send_request(self, command):
        try:
            self.client_socket.send(command.encode("utf-8"))
        except ConnectionResetError as e:
            print(f"Błąd połączenia: {e}. Serwer mógł zostać zamknięty.")
            raise
        except Exception as e:
            print(f"Inny błąd podczas wysyłania komendy: {e}")
            raise

    def recv_response(self):
        try:
            response = self.client_socket.recv(1024).decode("utf-8")
            print(response)
            return response
        except ConnectionResetError as e:
            print(f"Błąd połączenia: {e}. Serwer mógł zostać zamknięty.")
            raise   
        except Exception as e:
            print(f"Błąd podczas odbierania odpowiedzi: {e}")
            raise
        

====================
FILE: config.py

SERVER_CONFIG = {
    'host': "127.0.0.1",
    'port':  64623,
    'max_connections': 5,
    'buffer_size': 1024
}

ROLE_PERMISSIONS = {
        'admin': {
            "send"   : True,
            "read"   : True,
            "read-u" : True,
            "read-a" : True,
            "read-o" : True,
            "login"  : True,
            "logout" : True,
            "help"   : True,
            "info"   : True,
            "create" : True,
            "delete" : True,
            "edit"   : True
                },
            
        'user': {
            "send"   : True,
            "read"   : True,
            "read-u" : True,
            "read-a" : True,
            "read-o" : False,
            "login"  : True,
            "logout" : True,
            "help"   : True,
            "info"   : False,
            "create" : True,
            "delete" : False,
            "edit"   : False
            }
            }

DIC_HELP = {
        "send"   : "send - wysyłanie wiadomości do innego zarejestrowanego użytkownika",
        "read"   : "read - czytanie nowych wiadomości",
        "read-u" : "read-u - przegląd wszystkich wiadomości od wybranego użytkownika",
        "read-a" : "read-a - przegląd wszystkich wiadomości jakie ma użytkownik",
        "read-o" : "read-o - przegląd wszystkich wiadomości innego użytkownika (tylko  admin)",
        "login"  : "login - logowanie do systemu",
        "logout" : "logout - wylogowanie z systemu",
        "help"   : "help - zwraca listę dostępnych komend z krótkim opisem",
        "info"   : "info - zwraca informacje o wybranym użytkowniku (tylko admin)",
        "create" : "create - tworzenie nowego użytkownika",
        "delete" : "delete - usuwanie użytkownika (tylko admin)",
        "edit"   : "edit - edycja roli użytkownika  (tylko admin)"
        }

PATH_USERS_DB = 'data/users.json'
PATH_MESSAGES_DB = 'data/messages.json'

====================
FILE: DbManager.py
import socket as s
import time
import pandas as pd
from datetime import datetime
import json
from config import *
from models.user import User


class DbManager():
    def __init__(self):
        self.users_db = PATH_USERS_DB
        self.messages_db = PATH_MESSAGES_DB

    def handle_db_exceptions(func):           
        def wrapper(self, *args, **kwargs):   # wrapper to nowa funkcja, która "owija" oryginalną
            try:
                return func(self, *args, **kwargs)  # wywołanie oryginalnej funkcji
            except FileNotFoundError:
                print(f"Nie znaleziono pliku bazy")
                return False
            except json.JSONDecodeError:
                print("Błąd podczas parsowania pliku JSON")
                return False
            except PermissionError:
                print(f"Brak uprawnień do zapisu pliku")
                return False
            except IOError as e:
                print(f"Błąd podczas operacji na pliku: {e}")
                return False
            except ValueError as e:
                print(f"Błąd walidacji danych: {e}")
                return False
            except Exception as e:
                print(f"Wystąpił nieoczekiwany błąd: {e}")
                return False
        return wrapper   

    @handle_db_exceptions
    def add_message_into_db(self, message):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        data['messages'].append(message)

        with open(self.messages_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        return True

    @handle_db_exceptions
    def delete_message_from_db(self, message_id, username):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        data['messages'] = [msg for msg in data['messages'] if msg['id'] != message_id and msg['username'] != username]
        with open(self.messages_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, ensure_ascii=False, indent=4)
        return True
 
    @handle_db_exceptions
    def get_all_messages_user(self, username):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        filtered_messages = [msg['text'] for msg in data['messages'] if msg['username'] == username]
        return filtered_messages
      
    @handle_db_exceptions
    def get_all_messages_user_from_sender(self, username, sender):
            with open(self.messages_db, 'r', encoding='utf-8') as file:
                data = json.load(file)
            filtered_messages = [msg['text'] for msg in data['messages'] if (msg['username'] == username and msg['sender'] == sender)]
            return filtered_messages
        
    @handle_db_exceptions
    def get_all_new_messages_user(self, username):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            #print("test)")
            data = json.load(file)
        new_messages = list([msg['text'], msg['sender'], msg['send_time']] for msg in data['messages'] if (msg['username'] == username and msg['is_read'] == 0))
        return new_messages
             
    @handle_db_exceptions
    def get_number_new_message_user(self, username):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        new_messages = [msg for msg in data['messages'] if (msg['username'] == username and msg['is_read'] == 0)]
        return len(new_messages)
    
    @handle_db_exceptions
    def change_message_status_into_read(self, username):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        for msg in data['messages']:
            if msg['username'] == username and msg['is_read'] == 0:
                msg['is_read'] = 1
                msg['read_time'] = datetime.now().strftime('%Y-%m-%d godz. %H:%M')
        with open(self.messages_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4, ensure_ascii=False)    
        return True
            
    @handle_db_exceptions           
    def get_user_info(self, username):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        for user in data['users']:
                if user['username'] == username:
                    user_info = user
                    break
        return user_info
    
    @handle_db_exceptions
    def delete_user_from_db(self, username):  #usuwanie po nazwa uzytkownika, zalozono ze jest unikalna
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        data['users'] = [user for user in data['users'] if user['username'] != username] #nowa lista użytkowników bez usuniętego
        with open(self.users_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4, ensure_ascii=False)
        return True
    
    #@handle_db_exceptions            
    def add_user_into_db(self, user):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        data['users'].append(user) 
        with open(self.users_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4, ensure_ascii=False)
        return True

    @handle_db_exceptions
    def edit_user_role_in_db(self, username, new_role):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        #print(users)
        for user in data['users']:
            if user['username'] == username :
                user['role'] = new_role
                print(f"Zmieniono rolę użytkownika {username} na {new_role}")
                break
        # Zapisz zaktualizowane dane
        with open(self.users_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4, ensure_ascii=False)    
        return True
    
    @handle_db_exceptions
    def change_login_time_in_db(self, username):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        print(username)
        for user in data['users']:
            if user['username'] == username :
                user['login_time'] = datetime.now().isoformat()
                break
        # Zapisz zaktualizowane dane
        with open(self.users_db, 'w', encoding='utf-8') as file:
            json.dump(data, file, indent=4, ensure_ascii=False)    
        return True
    
    @handle_db_exceptions
    def is_user_in_db(self, username):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        #print(data)
        users = data.get('users', {})
        return any(
            user.get('username') == str(username)
            for user in users
        )
    
    @handle_db_exceptions
    def is_message_in_db(self, message_id):
        with open(self.messages_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        #print(data)
        messages = data.get('messages', {})
        return any(
            message.get('id') == str(message_id)
            for message in messages
        )
    
    @handle_db_exceptions
    def is_user_password_in_db(self, username, password):
        with open(self.users_db, 'r', encoding='utf-8') as file:
            data = json.load(file)
        #print(data)
        users = data.get('users', {})
        return any(
            user.get('username') == str(username) and 
            user.get('password') == str(password)
            for user in users
        )
    
    @handle_db_exceptions
    def get_user_password(self, username):
        with open(PATH_USERS_DB, 'r', encoding='utf-8') as file:
            data = json.load(file)
        password = None
        for user in data['users']:
                if user['username'] == username:
                    password = user['password']
                    break
        return password
    
    @handle_db_exceptions
    def get_user_role(self, username):
        with open(PATH_USERS_DB, 'r', encoding='utf-8') as file:
            data = json.load(file)
        role = None
        for user in data['users']:
                if user['username'] == username:
                    role = user['role']
                    break
        return role
           


    

====================
FILE: server.py
from services.ServerConactionManager import ServerManager
from services.DbManager import DbManager
from services.UserServerManager import UserServerManager
import socket as s


# po zmnknięciu połączenia z klientemserwer czeka na nowe połączenie
# Zredygnowano z  Menedżer kontekstu (with),  który 
# automatycznie zamyka połączenie po wyjściu z bloku, 
# co nie jest pożądane w przypadku serwera, który powinien działać ciągle.

server = ServerManager()
server.start_server()

try:
    while True:  # Główna pętla serwera
        client_socket, address = server.accept_client()
        print(f"Połączono z klientem: {address}")
        user_manager = UserServerManager()
        
        try:
            while True:  # Pętla obsługi pojedynczego klienta
                request = server.handle_client(client_socket)
                if not request: # Jeśli nie ma danych, bo połączenie zostało przerwane
                    break
                    
                command = request[0]
                data_input = request[1] 
                print(request)
                print(command)
                print(data_input) 
                if not command:  # Sprawdzenie czy komenda nie jest pusta
                    continue
                
                if command == "logout":
                    print(f"Klient {address} się wylogował")
                    break  # Przerywa tylko wewnętrzną pętlę
                
                if command in user_manager.command_map:
                    if len(data_input) > 0:
                        response = str(user_manager.command_map[command](command, *data_input.values()))
                    else:
                        response = str(user_manager.command_map[command](command))
                    client_socket.send(response.encode("utf-8"))
                         
        except Exception as e:
            print(f"Błąd podczas obsługi klienta {address}: {e}")
        finally:
            client_socket.close()
            print(f"Zamknięto połączenie z klientem {address}")
            
except KeyboardInterrupt:
    print("\nZamykanie serwera...")
except Exception as e:
    print(f"Błąd krytyczny serwera: {e}")
finally:
    server.stop_server()    
        

====================
FILE: ServerConactionManager.py
import socket as s
from datetime import datetime
from config import *
import ast

class ServerManager():
    def __init__(self):
        self.host = SERVER_CONFIG['host']
        self.port = SERVER_CONFIG['port']
        self.max_connections = SERVER_CONFIG['max_connections']
        self.buffer_size = SERVER_CONFIG['buffer_size']
        self.server_socket = None
        
    def start_server(self):
        try:
            # Utworzenie i konfiguracja socketu
            self.server_socket = s.socket(s.AF_INET, s.SOCK_STREAM)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(self.max_connections)  # maksymalnie 5 połączeń w kolejce
            print(f"Serwer nasłuchuje na {self.host}:{self.port}")
            
        except s.error as e:
            print(f"Błąd podczas tworzenia serwera: {e}")
            raise

    def stop_server(self):
        # Zamknij połączenie
        if self.server_socket:
            self.server_socket.close()
            print("Serwer został zamknięty.")

    def accept_client(self):
        try:
            return self.server_socket.accept()
            
        except s.error as e:
            print(f"Błąd podczas akceptowania połączenia: {e}")
            raise

    def handle_client(self, client_socket):     
        try:
            data_string = client_socket.recv(1024).decode('utf-8')
            try:
                data_list = ast.literal_eval(data_string)
                return data_list
            except (ValueError, SyntaxError) as e:
                print(f"Błąd podczas parsowania danych: {e}")
                raise 
                
        except UnicodeDecodeError as e:
            print(f"Błąd dekodowania danych: {e}")
            raise 
        except s.error as e:
            print(f"Błąd połączenia: {e}")
            raise 



====================
FILE: user.py
import socket as s
import time
import os
from datetime import datetime
import json
from config import *


class User():
    def __init__(self):
        self.id = None  
        self.username = None
        self.password = None
        self.role = 'user'
        self.is_logged = False
        self.login_time = None
        self.create_time = None

    def is_user_allowed_to_command(self, command):
        permissions = ROLE_PERMISSIONS[self.role][command]
        return permissions


====================
FILE: UserClientManager.py
class UserClientManager:
    def __init__(self):
        self.command_map = {
                "send"   : self.request_send_message,
                "read"   : self.request_read_new_message,
                "read-u" : self.request_read_message_current_user_from_sender,
                "read-a" : self.request_read_all_message_current_user,
                "read-o" : self.request_read_message_user_from_sender,
                "login"  : self.request_login,
                "logout" : self.request_logout,
                "help"   : self.request_get_help,
                "info"   : self.request_get_user_info,
                "create" : self.request_create_new_user,
                "delete" : self.request_delete_user,
                "edit"   : self.request_edit_user_role,          
        } 

    def prepere_request(self):
        command = input("Podaj komendę: ").lower()
        
        if command in ("help", "read-a", "read", "logout"):
            data_input = []

        elif command in ("login", "create"):
            data_input_login = input("Podaj nazwę uzytkownika: ").strip().lower()
            data_input_password = input("Podaj hasło uzytkownika: ").strip()
            data_input = [data_input_login, data_input_password]

        elif command in ("send"):
            data_input_login = input("Odbiorca wiadomości - podaj nazwę uzytkownika: ").strip().lower()
            data_input_password = input("Wpisz treść wiadomości: ").strip()
            data_input = [data_input_login, data_input_password]
        
        elif command in ("read-u"):
            data_input = [input("Podaj nazwę użytkownika, od którego wiadomoścu chesz przeglądać: ")]

        elif command in ("read-o"):
            data_input_user = input("Podaj nazwę użytkownika, którego wiadomości chesz przeglądać: ").strip().lower()
            data_input_sander = input("Podaj nazwę nadawcy wiadomości: ").strip().lower()
            data_input = [data_input_user, data_input_sander]

        elif command in ("edit"):
            data_input_user = input("Podaj nazwę użytkownika, którego rolę chesz zmienić: ").strip().lower()
            data_input_role = input("Nowa rola: ").strip().lower()
            data_input = [data_input_user, data_input_role]
            
        elif command in ("info", "delete"):
            data_input = [input("Podaj nazwę użytkownika: ").lower()]
        
        elif command not in self.command_map or not command:
            data_input = []
            print("Komenda nie istnieje")
        return command, data_input    
    
    
    def request_login(self, command, username, password):
        request = [str(command), {
            "username": username,
            "password": password
        }]
        return self.set_format(request)

    def request_logout(self, command):
        request = [str(command), {}]
        return self.set_format(request)
        
    def request_create_new_user(self,command, username, password):
        request = [str(command), {
            "username": username,
            "password": password
        }]
        return self.set_format(request)
    
    def request_send_message(self, command, text, reciver):
        request =[str(command), {
            "text": text,
            "username": reciver
        }]
        return self.set_format(request)

    def request_read_message_user_from_sender(self, command, username, sender):
        request = [str(command), {
            "username": username,
            "sender": sender
        }]
        #print(request)
        return self.set_format(request)
    
    def request_read_new_message(self, command):
        request = [str(command), {}]
        return self.set_format(request)

    def request_read_message_current_user_from_sender(self, command, sender):
        request = [str(command), {
            "username": sender
        }]
        return self.set_format(request)

    def request_read_all_message_current_user(self, command):
        request = [str(command), {}]
        return self.set_format(request)
    
    def request_get_help(self, command):
        request = [str(command), {}]
        return self.set_format(request)
    
    def request_get_user_info(self, command, username):
        request = [str(command), {
            "username": username
        }]
        return self.set_format(request)
    
    def request_delete_user(self, command, username):
        request = [str(command), {
            "username": username
        }]
        return self.set_format(request)
    
    def request_edit_user_role(self,command, username, new_role):
        request = [str(command), {
            "username": username,
            "new_role": new_role
        }]
        return self.set_format(request)

    def set_format(self, request):  #przygotowany na potrzeby zmiany formatu wysyłania requestu do serwera
        list_data = request
        return list_data













====================
FILE: UserServerManager.py
import bcrypt
from datetime import datetime
from config import *
from models.user import User
from services.DbManager import DbManager
from datetime import datetime
import time
import os

class UserServerManager: 
    def __init__(self):
        self.current_user = User()
        self.db_manager = DbManager()
        self.command_map = {
            "send"   : self.send_message,
            "read"   : self.read_new_message,
            "read-u" : self.read_message_current_user_from_sender,
            "read-a" : self.read_message_current_user,
            "read-o" : self.read_message_user_from_sander,
            "login"  : self.login_user,
            "logout" : self.logout_user,
            "help"   : self.get_help,
            "info"   : self.get_user_info,
            "create" : self.create_new_user,
            "delete" : self.delete_user,
            "edit"   : self.edit_user_role
        }

    def get_help(self, command):
        if self.current_user.is_user_allowed_to_command(str(command)): 
            list =[] 
            for key, value in DIC_HELP.items():
                list.append(f"{key}: {value}")
            response = "\n".join(list)
        else:
            response = "Nie masz uprawnień do tej komendy"
        return response

    def send_message(self, command, receiver, text):
        number_new_message = self.db_manager.get_number_new_message_user(receiver)
        is_receiver_in_db = self.db_manager.is_user_in_db(receiver)
        #print(number_new_message)
        if self.current_user.is_user_allowed_to_command(str(command)) and self.current_user.is_logged and is_receiver_in_db:
            if number_new_message < 5 and len(text) <= 255:
                message = {
                    "id": self.generate_id_message(),
                    "username": receiver,
                    "sender": self.current_user.username,
                    "text": text,
                    "send_time": datetime.now().strftime('%Y-%m-%d godz. %H:%M'),
                    "read_time": None,
                    "is_read": 0
                }
                
                self.db_manager.add_message_into_db(message)
                response = f"Wiadomość do {receiver} została wysłana"
            else:
                response = f"Nie możesz wysłać wiadomości do {receiver} - jego skrzynka jest przepełniona lub wiadomość jest dłuższa niż 255 znaków"
        else:
            response = f"Nie masz uprawnień do tej komendy lub użytkownik {receiver} nie istnieje"
        return response

    def read_message_current_user_from_sender(self, command, sender):
        if self.current_user.is_user_allowed_to_command(str(command)) and  self.current_user.is_logged:
            messages = self.db_manager.get_all_messages_user_from_sender(self.current_user.username, sender)
            return messages 
        else:
            return "Nie masz uprawnień do tej komendy"

    def read_message_current_user(self, command):
        if self.current_user.is_user_allowed_to_command(str(command)) and  self.current_user.is_logged:
            messages = self.db_manager.get_all_messages_user(self.current_user.username)
            self.db_manager.change_message_status_into_read(self.current_user.username)
            response = messages   
        else:
            response = f"Nie masz uprawnień do tej komendy"
        return response    

    def read_message_user_from_sander(self, command, user, sender):
        if self.current_user.is_user_allowed_to_command(str(command)) and  self.current_user.is_logged:
            messages = self.db_manager.get_all_messages_user_from_sender(user, sender) 
            self.db_manager.change_message_status_into_read(self.current_user.username)
            return messages 
        else:
            return "Nie masz uprawnień do tej komendy"

    def read_new_message(self, command):
        if self.current_user.is_user_allowed_to_command(str(command)) and  self.current_user.is_logged:
            new_messages = self.db_manager.get_all_new_messages_user(self.current_user.username)
            self.db_manager.change_message_status_into_read(self.current_user.username)
            print(new_messages)
            response = []
            for message in new_messages:
                response.append(f"Wiadomosc od: {message[1]}: {message[0]} / wysłano: {message[2]}")
            if response:
                return "\n".join(response)
            else:
                return "Nie masz nowych wiadomości"
        else:
            response =  "Nie masz uprawnień do tej komendy"
        return response

    def get_user_info(self, command, user):
        #print(self.current_user.is_user_allowed_to_command(str(command)))
        #print(self.current_user.is_logged)
        if self.current_user.is_user_allowed_to_command(str(command)) and self.current_user.is_logged:   
            messages = self.db_manager.get_user_info(user) 
            response = messages 
        else:
            response = "Nie masz uprawnień do tej komendy"
        return response

    def delete_user(self, command, username):
        if self.current_user.is_user_allowed_to_command(str(command)) and  self.current_user.is_logged and username != self.current_user.username:
            is_delete = self.db_manager.delete_user_from_db(username) 
            if is_delete:
                response = "Użytkownik został usunięty"
            else:
                response = "Użytkownik nie został usunięty"
        else:
            response = "Nie masz uprawnień do tej komendy"
        return response

    def create_new_user(self,command, username, password):
        if self.current_user.is_user_allowed_to_command(str(command)) and not self.current_user.is_logged:
            if self.db_manager.is_user_in_db(username):
                response = "Użytkownik już istnieje"
            elif len(password) < 2 and len(username) < 2:
                response = "Hasło musi mieć minimum 2 znaki"
            else:
                hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
                user = {
                    "id": self.generate_id_user(),
                    "username": username,
                    "role": "user",
                    "password": hashed_password.decode('utf-8'),
                    "login_time": None,
                    "create_time": datetime.now().isoformat()
                }
                #print(user)
                is_add = self.db_manager.add_user_into_db(user)
                if is_add:  
                    response = "Użytkownik został dodany do bazy danych"
                else:
                    response = "Użytkownik nie został dodany do bazy danych"
            
        else:
            response = "Nie masz uprawnień do tego komendy lub jestes juz zalogowany"
        return response

    def login_user(self, command, username, password):
        try:
            if not username or not password:
                return "Nazwa użytkownika i hasło nie mogą być puste"
                
            elif self.current_user.is_user_allowed_to_command(str(command)) and not self.current_user.is_logged:
                stored_password = self.db_manager.get_user_password(username)
                stored_role = self.db_manager.get_user_role(username)
                #print(stored_password)
                if stored_password and bcrypt.checkpw(password.encode('utf-8'), stored_password.encode('utf-8')):
                    self.db_manager.change_login_time_in_db(username)
                    #print(self.db_manager.change_login_time_in_db(username))
                    self.current_user.username = username
                    self.current_user.password = stored_password
                    self.current_user.is_logged = True
                    self.current_user.role = stored_role
            
                    response = "Użytkownik został zalogowany"
                else:
                    response = "Nieprawidłowa nazwa użytkownika lub hasło"
            else:
                response = "Nie masz uprawnień do tej komendy lub jesteś już zalogowany"
            return response
            
        except UnicodeEncodeError:
            return "Hasło zawiera nieprawidłowe znaki"
        except Exception as e:
            return f"Wystąpił nieoczekiwany błąd: {str(e)}"

    def logout_user(self, command):
        if self.current_user.is_user_allowed_to_command(str(command)) and self.current_user.is_logged:
            self.current_user.is_logged = False
            return "Uzytkownik został wylogowany"
        return "Uzytkownik nie był zalogowany"

    def edit_user_role(self, command, username, new_role):
        is_user_in_db = self.db_manager.is_user_in_db(username)
        if self.current_user.is_user_allowed_to_command(command) and self.current_user.is_logged and is_user_in_db:
            self.db_manager.edit_user_role_in_db(username, new_role)
            return "Rola zostala zmieniona"
        else:
            return "Nie masz uprawnień do tej komendy lub użytkownik nie istnieje"
        
    def generate_id_user(self):
        return int(time.time() * 1000)
    
    def generate_id_message(self):
        return int(time.time() * 1000)





